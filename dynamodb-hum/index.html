<!DOCTYPE html><html lang="en"><head><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-E49JT23TS5"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());    gtag('config', 'G-E49JT23TS5');</script><link href="assets/favicons/apple-touch-icon-57x57.png" rel="apple-touch-icon-precomposed" sizes="57x57"><link href="assets/favicons/apple-touch-icon-114x114.png" rel="apple-touch-icon-precomposed" sizes="114x114"><link href="assets/favicons/apple-touch-icon-72x72.png" rel="apple-touch-icon-precomposed" sizes="72x72"><link href="assets/favicons/apple-touch-icon-144x144.png" rel="apple-touch-icon-precomposed" sizes="144x144"><link href="assets/favicons/apple-touch-icon-60x60.png" rel="apple-touch-icon-precomposed" sizes="60x60"><link href="assets/favicons/apple-touch-icon-120x120.png" rel="apple-touch-icon-precomposed" sizes="120x120"><link href="assets/favicons/apple-touch-icon-76x76.png" rel="apple-touch-icon-precomposed" sizes="76x76"><link href="assets/favicons/apple-touch-icon-152x152.png" rel="apple-touch-icon-precomposed" sizes="152x152"><link href="assets/favicons/favicon-196x196.png" rel="icon" sizes="196x196" type="image/png"><link href="assets/favicons/favicon-96x96.png" rel="icon" sizes="96x96" type="image/png"><link href="assets/favicons/favicon-32x32.png" rel="icon" sizes="32x32" type="image/png"><link href="assets/favicons/favicon-16x16.png" rel="icon" sizes="16x16" type="image/png"><link href="assets/favicons/favicon-128.png" rel="icon" sizes="128x128" type="image/png"><meta content=" " name="application-name"><meta content="#FFFFFF" name="msapplication-TileColor"><meta content="mstile-144x144.png" name="msapplication-TileImage"><meta content="mstile-70x70.png" name="msapplication-square70x70logo"><meta content="mstile-150x150.png" name="msapplication-square150x150logo"><meta content="mstile-310x150.png" name="msapplication-wide310x150logo"><meta content="mstile-310x310.png" name="msapplication-square310x310logo"><!-- Social cards --><meta content="@ggfuzz" name="twitter:site"><meta content="Pine Cabin" property="og:site_name"><meta content="DynamoDB Hum" name="twitter:title"><meta content="DynamoDB Hum" property="og:title"><meta content="article" property="og:type"><meta content="DynamoDB is interesting because of its ability to scale. Let us talk about the bits of DynamoDB relevant at scale." name="twitter:description"><meta content="DynamoDB is interesting because of its ability to scale. Let us talk about the bits of DynamoDB relevant at scale." property="og:description"><meta content="summary_large_image" name="twitter:card"><meta content="https://pinecab.com/assets/images/gradefire3.jpg" name="twitter:image"><meta content="https://pinecab.com/assets/images/gradefire3.jpg" property="og:image"><!-- end of Social cards --><meta charset="UTF-8"><meta content="width=device-width, initial-scale=1.0" name="viewport"><meta content="ie=edge" http-equiv="X-UA-Compatible"><title>DynamoDB Hum</title><link href="/assets/css/content.css" rel="stylesheet"></head><body class="text-center"><div class="cover-container d-flex w-100 h-100 p-3 mx-auto flex-column"><header class="masthead mb-auto"><div class="inner"><h3 class="masthead-brand">Pine Cabin</h3><nav class="nav nav-masthead justify-content-center"><a class="nav-link" href="/">Home</a><a class="nav-link active" href="/contents">Contents</a><a class="nav-link" href="/about">About</a></nav></div></header><main class="inner cover" role="main"><h1 class="cover-heading">DynamoDB Hum</h1><div class="display-date">December 15, 2013</div><p>“DynamoDB is a fast, fully managed NoSQL database service that makes it simple and cost-effective to store and retrieve any amount of data, and serve any level of request traffic. All data items are stored on Solid State Drives (SSDs), and are replicated across 3 Availability Zones for high availability and durability.”</p>

<p>DynamoDB is interesting because of its ability to scale. Let us talk about the bits of DynamoDB relevant at scale.</p>

<h2 id="keys">Keys</h2>
<p>Imagine our DynamoDB table is a giant hash. We call each key of that hash the hash key – clever, eh? When we query or get an item from DynamoDB we must know (or be able to deduce–more on this later) its exact hash key.</p>

<p>It is possible to configure DynamoDB such that there is one item–an item is a hash–per hash key. That is boring. We will not talk about that.</p>

<p>Instead imagine that our giant hash is full of arrays that are full of items. These arrays are indexed by each item’s range key and can be accessed using the Query API.</p>

<p>Consider a table containing Articles. We can use the UserId value of the article as the hash key and the UpdatedAt value as the range key. We can now use the Query API to efficiently retrieve a user’s articles for the last thirty days. DynamoDB goes to the hash key location, scans through the range keys (we can tell it which direction to look) and there we go.</p>

<h2 id="indexes">Indexes</h2>
<p>One table with two indexes means we need roughly triple the write capacity compared to the table alone. Solutions that involve external indexes require management of write capacities across multiple tables and possible data inconsistency–boo–but in the next few weeks AWS will offer Global Secondary Indexes which will hopefully render such schemes obsolete. Local Secondary Indexes–additional range key indexes–are available now.</p>

<p>What is an “additional range key index”?! Sorry! Remember our giant hash filled with arrays filled with hashes, those arrays ordered on a range key value selected from the hashes they contain? LSIs allow us to specify additional range keys so, to add to our above example, we have UserId as the hash key and UpdatedAt as the range key–we add an LSI so we can make a second range key on Name. Now we can also query Articles for a user’s articles that have a certain name or start with ‘z’ or whatever.</p>

<p>Global Secondary Indexes will allow us to add additional hash keys to index our tables. If we add Name as a GSI instead of an LSI then we can query all articles by name rather than just querying articles by name for a given user.</p>

<h2 id="partitioning">Partitioning</h2>
<p>The write capacity of a table is divided evenly among a number of partitions. We do not know the number of partitions but it increases/decreases as capacity is added/removed. In order to utilize our total provisioned write capacity we must evenly spread writes across partitions to avoid hotspots because exceeding the capacity of any one partition will cause our table to be throttled. One approach is to choose random hash keys but this requires that we always know the exact (random) hash key of the item we want. To get around this a hash key index (external or GSI) is added. But! That index has the same hash key constraint–indexes are just other DynamoDB tables so the index hash key will suffer the same partitioning hotspot issues. Thus we have not really resolved the issue by choosing a random primary hash key but rather moved it elsewhere and doubled our required write capacity for the effort.</p>

<p>What to do now? There are two primary options. One is we can use something useful, like a UserId, as the primary hash key and add something to help randomize it. For example we could prepend a random digit 0-9 to each hash key. If we are storing a key for a specific item somewhere we can store it with the random digit and use that to get the item directly. If, on the other hand, we need to query for an item and we are not sure which of the ten possible hash keys it uses we have to query each of them (or better if we can figure that out) until we find it.</p>

<p>The other option is to spread writes for a given hash key out over time (or better if we can figure that out). Continuing with our example above let us imagine our app can import a user’s articles from WordPress in bulk. When that job runs for a prolific blogger we are suddenly beating the snot out of that UserId hash key. Throw those writes in a queue and work on them over time and that snot-beaten spot is not so hot.</p>

<p>Which approach to take (perhaps both!) and the implementation details will naturally depend on our data and usage patterns, but now we know enough to reason about the problem.</p>

<h2 id="patterns">Patterns</h2>
<p>DynamoDB’s constraints might be off-putting for a lesser data store, but DynamoDB’s speed, scalability, simplicity and cost make its constraints worth thinking about. There are interesting and useful patterns to be discovered.</p>

<p>For example let us go back to our Articles table example from above. We will use the UserId for the hash key again. But this time we are going to make a composite range key by prepending a SequenceId to a randomly-generated UuId. [Note that foreign keys–from Dynamo or other data stores–are an interesting choice to use here instead of random uuids long as they are unique within the primary hash key.] We take advantage of DynamoDB’s flexible schema and store the metadata item for a sequence–representing a Category–in position 0 and store the data items for a sequence–representing articles–in positions 1-n. We write the metadata item last to ensure consistency (potentially at the expense of some orphan items) and persist the total number of items written in it. We could also persist some sort of sequence index here, tags related to the sequence, etc. Once the metadata item is written we consider the sequence immutable. Now we can query a user’s categories by searching for all items that start with 0. From there we select a category whose articles we want; we know from the metadata item the sequence’s uuid and how many items are in it so we batch_get them. Thus if our metadata indicates our sequence contains three items we do a batch_get for hash_key[1.uuid, 2.uuid, 3.uuid] and DynamoDB efficiently retrieves the sequence for us. Yay. We could, of course, get them one at a time or in paginated batches instead. This covers a lot of use cases and does so without using an index. Naturally an appropriate solution to the partitioning problem above must be implemented as well.</p>

<h2 id="deleting">Deleting</h2>
<p>Deleting items from DynamoDB at scale is expensive. Avoid it if possible. Prefer to rotate tables instead–a new table for each month, for example–eventually expiring or moving old tables to cold storage.</p>

<h2 id="backups--reporting">Backups &amp; Reporting</h2>
<p>If we are running at scale we are probably going to be very unhappy trying to restore a DynamoDB table of any significant size from some other media. Rotating tables helps here by keeping things small but the only real way to quickly recover from, say, an accidentally dropped table, is a hot spare table. Also if we want to analyze the data on a table, as with reporting or other data mining activity, the recommended method is to use a hot spare table and do the analysis on it so as not to impact performance of the production table.</p>

<h2 id="scan-api">Scan API</h2>
<p>The Scan API iterates over each item in a DynamoDB table. Just no.</p>

<h2 id="conclusion">Conclusion</h2>
<p>Whew! There is plenty more to talk about but this should be enough to get us moving in the right direction. I will write a follow up article if there is interest. Have fun! Feel free to hit me up <a href="https://twitter.com/ggfuzz">@ggfuzz</a>.</p>

<h2 id="update">UPDATE</h2>
<p>I wrote <a href="https://github.com/fuzz/moe">a Ruby gem for this</a>.</p>
<br></main><footer class="mastfoot mt-auto"><div class="inner"><p class="copyright">&#169;2022 Jason Leonard</p></div></footer></div></body></html>